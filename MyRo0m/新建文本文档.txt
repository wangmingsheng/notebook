是Chrome, 其默认有最小字体大小限制
.space {
    font-size: 0;
    -webkit-text-size-adjust:none;
}

jsx中行内元素换行和空白符不会产生间隙？？

setUrl 和 history.back

''.split(',')     ['']

input date  datetime-local  绝对定位且是在滑动区时，使滑动时不显示
-webkit-overflow-scrolling:touch;

盒子模型：
在一个容器框内，定义一个绝对定位的元素：
1：相对于该容器  那么overflow：hidden  等属性会限制该元素
2：相对于该容器的父元素  那么不会限制

父容器会被子元素撑开？不一定，正常流中是会的

for in 遍历对象可枚举的所有属性

-webkit-text-stroke-width: 0.2px;文字描边宽度

line-height 只影响字体的  会被子元素继承
伪元素不在普通流中 
contenteditable 使元素可编辑 user-select: text

绝对定位的时候 z-index也很重要，默认不对其设置，不同浏览器可能会默认不同

调试样式的时候多用background-color进行调试

奇怪现象： iPhone scroll不显示

div 等块级元素内有 inline-bloack 元素时：即使内部inline-block宽高都为0，因为块级元素有默认行高，所以会以默认行高方式撑开

console.log() 是异步的？是chrom浏览器的bug？

this.setState 可以接收第二个参数，渲染完成进行回调

//gim  正则   m:表示匹配换行符前后的行起始和行结束

相对定位   自己相对位移，占有原来的位置，周围元素保持不动
z-index 为负数时盒子模型中处于底层，比父元素还底？有时间的时候要着重研究盒子模型z轴上的分布
z-index 为负数时 事件的target获取不到本身？

绝对定位不加left rigth等四属性，会按正常流分布？待测试

word-break 处理换行   white-space? 处理空白
绝对定位能改变display为block，不同的display的绝对定位有何不同
行内元素有border吗？

块级元素可继承，行内元素可继承，列表元素可继承。。的属性有哪些?


不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。
所有元素可继承：visibility和cursor。
内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。
终端块状元素可继承：text-indent和text-align。
列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。
表格元素可继承：border-collapse。

event事件参数不能用于闭包中，会丢失，是不是参数都这样？？


object.do(someThing) do里的this指向的是object
object.do.bind(this, someThing) do里的this指向的是定义中的this

布局与事件



浏览器缓存，刷新不会重新加载，原理？后台相关？想要一定会重新加载，地址后面加?<?=time()?>   

服务器不但可以获取ip也能获取域名？

debugger	



react props中的callBack函数callBack={this.progressEnd} 相当于是  callBack={function() {this.progressEnd()}}

        var reader = new FileReader();
        reader.readAsDataURL(e.currentTarget.files[0]);
        reader.onload = function(e) {
            console.log(e.currentTarget.result)
        };

父容器要被子元素自动撑开，会多出高度的问题？ 1.父容器line-height设置为0？ 2.子元素浮动，然后清浮动

js  blob 对象

react 渲染 key的关键性，当key不变时那只是获得的属性改变问题，不会走初始化组件方法
数组也是对象，但是数组用[]等标准方法定义的成员是不可遍历的，用点号赋值的属性可遍历
变量作用，变量生命周期等问题，数组成员被splice删除了，也不一定会从内存中移除，当它有被另一个对象所引用时


 Warning: `div` was passed a style object that has previously been mutated   解决办法就是 对syle赋值一个新对象


react 组件渲染 ：
属性有改变时，触发componentWillReceiveProp(nextProps)，只要组件任何一属性有改变，那么nextProps就不会等于this.props,  在这个函数内只要有对state操作，那么接下来渲染之前要触发的函数shouldComponentUpdate(nextProps, nextState)中的nextState参数就好新创建一个state对象，这个对象的值就是this.state的克隆加上之前的操作，如果之前有操作，那么this.state != nextState肯定为true的。
---------》除了第一次初始化组件，每次render之前必须询问shouldComponentUpdate ,ps: 只要进了shouldComponentUpdate nextState已经是决定会不会等于this.state
setState后又被setState在事件很短的情况下可能不会渲染两次，后者生效


appearance = none 会是 input type=radio 看不见

发现不能撑开，高度丢失，首先可能是浮动，绝对定位等问题

input框的键盘输入值keydown 返回false（ps：必须是false，为啥？内部实现有关系）时，键盘的值输入不进去   
两变量比较的规则：1：两数值 2 有一个树字符串，另一个转为字符串 3 一个对象，会把对象先转换为valuof tostring  3 一个boolen 先转换为数字


jquery closest 向上遍历第一个  $object.is('')  比较dom

临时函数的this 指向window？

fieldset 给表单分组  <legend> 标签为 fieldset 元素定义标题。
h5中 
disabled	disabled规定应该禁用 fieldset。
form	form_id	规定 fieldset 所属的一个或多个表单。
name	value	规定 fieldset 的名称。


background  url 0 0 norepeat
position 0 0 图片的左上角  在显示区域不够大的情况下要显示图片的中间位置  x y 都是负值

transition: left .5s liner;
animation: name duration cubic-bezier .2s infinite alternate

animation: change .5s cubic-bezier infinite; 
@keyframs change{
 0% {left: 10px;}
 50% {left: 50px;}
 100% {left: 100px;}
}

手机没有端元素没有hover事件